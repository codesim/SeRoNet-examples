//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------
#ifndef ROSCOMMON_MSGS_VISUALIZATION_MSGS_MARKER_CORE_H_
#define ROSCOMMON_MSGS_VISUALIZATION_MSGS_MARKER_CORE_H_

#include "ROSCommon_msgs/Visualization_msgs_MarkerData.hh"
#include "ROSCommon_msgs/Geometry_msgs_Pose.hh"
#include "CommBasicObjects/CommTimeStamp.hh"
#include "ROSRos_core/Std_msgs_ColorRGBA.hh"
#include "ROSCommon_msgs/Geometry_msgs_Vector3.hh"
#include "ROSRos_core/Std_msgs_Header.hh"
#include "ROSCommon_msgs/Geometry_msgs_Point.hh"

#include <iostream>
#include <string>
#include <list>

namespace ROSCommon_msgs {
	
class Visualization_msgs_MarkerCore {
protected:
	// data structure
	ROSCommon_msgsIDL::Visualization_msgs_Marker idl_Visualization_msgs_Marker;
	
public:
	// give a publicly accessible type-name for the template parameter IDL
	typedef ROSCommon_msgsIDL::Visualization_msgs_Marker DATATYPE;
	
	#ifdef ENABLE_HASH
		static size_t generateDataHash(const DATATYPE &);
	#endif
	
	static const char* getCompiledHash();
	static void getAllHashValues(std::list<std::string> &hashes);
	static void checkAllHashValues(std::list<std::string> &hashes);
	
	// default constructors
	Visualization_msgs_MarkerCore();
	Visualization_msgs_MarkerCore(const DATATYPE &data);
	// default destructor
	virtual ~Visualization_msgs_MarkerCore();
	
	const DATATYPE& get() const { return idl_Visualization_msgs_Marker; }
	operator const DATATYPE&() const { return idl_Visualization_msgs_Marker; }
	DATATYPE& set() { return idl_Visualization_msgs_Marker; }

	static inline std::string identifier(void) { return "ROSCommon_msgs::Visualization_msgs_Marker"; }
	
	// helper method to easily implement output stream in derived classes
	void to_ostream(std::ostream &os = std::cout) const;
	
	// convert to xml stream
	void to_xml(std::ostream &os, const std::string &indent = "") const;
	
	// restore from xml stream
	void from_xml(std::istream &is);
	
	// User Interface
	
	// getter and setter for element Header
	inline ROSRos_core::Std_msgs_Header getHeader() const { return ROSRos_core::Std_msgs_Header(idl_Visualization_msgs_Marker.header); }
	inline Visualization_msgs_MarkerCore& setHeader(const ROSRos_core::Std_msgs_Header &header) { idl_Visualization_msgs_Marker.header = header; return *this; }
	
	// getter and setter for element Ns
	inline std::string getNs() const { return idl_Visualization_msgs_Marker.ns; }
	inline Visualization_msgs_MarkerCore& setNs(const std::string &ns) { idl_Visualization_msgs_Marker.ns = ns; return *this; }
	
	// getter and setter for element Id
	inline int getId() const { return idl_Visualization_msgs_Marker.id; }
	inline Visualization_msgs_MarkerCore& setId(const int &id) { idl_Visualization_msgs_Marker.id = id; return *this; }
	
	// getter and setter for element Type
	inline int getType() const { return idl_Visualization_msgs_Marker.type; }
	inline Visualization_msgs_MarkerCore& setType(const int &type) { idl_Visualization_msgs_Marker.type = type; return *this; }
	
	// getter and setter for element Action
	inline int getAction() const { return idl_Visualization_msgs_Marker.action; }
	inline Visualization_msgs_MarkerCore& setAction(const int &action) { idl_Visualization_msgs_Marker.action = action; return *this; }
	
	// getter and setter for element Pose
	inline ROSCommon_msgs::Geometry_msgs_Pose getPose() const { return ROSCommon_msgs::Geometry_msgs_Pose(idl_Visualization_msgs_Marker.pose); }
	inline Visualization_msgs_MarkerCore& setPose(const ROSCommon_msgs::Geometry_msgs_Pose &pose) { idl_Visualization_msgs_Marker.pose = pose; return *this; }
	
	// getter and setter for element Scale
	inline ROSCommon_msgs::Geometry_msgs_Vector3 getScale() const { return ROSCommon_msgs::Geometry_msgs_Vector3(idl_Visualization_msgs_Marker.scale); }
	inline Visualization_msgs_MarkerCore& setScale(const ROSCommon_msgs::Geometry_msgs_Vector3 &scale) { idl_Visualization_msgs_Marker.scale = scale; return *this; }
	
	// getter and setter for element Color
	inline ROSRos_core::Std_msgs_ColorRGBA getColor() const { return ROSRos_core::Std_msgs_ColorRGBA(idl_Visualization_msgs_Marker.color); }
	inline Visualization_msgs_MarkerCore& setColor(const ROSRos_core::Std_msgs_ColorRGBA &color) { idl_Visualization_msgs_Marker.color = color; return *this; }
	
	// getter and setter for element Lifetime
	inline CommBasicObjects::CommTimeStamp getLifetime() const { return CommBasicObjects::CommTimeStamp(idl_Visualization_msgs_Marker.lifetime); }
	inline Visualization_msgs_MarkerCore& setLifetime(const CommBasicObjects::CommTimeStamp &lifetime) { idl_Visualization_msgs_Marker.lifetime = lifetime; return *this; }
	
	// getter and setter for element Frame_locked
	inline bool getFrame_locked() const { return idl_Visualization_msgs_Marker.frame_locked; }
	inline Visualization_msgs_MarkerCore& setFrame_locked(const bool &frame_locked) { idl_Visualization_msgs_Marker.frame_locked = frame_locked; return *this; }
	
	// getter and setter for element Points
	/**
	 * Getter methods for element idl_Visualization_msgs_Marker.points of type vector<ROSCommon_msgs::Geometry_msgs_Point>
	 */
	inline std::vector<ROSCommon_msgs::Geometry_msgs_Point> getPointsCopy() const { 
		return std::vector<ROSCommon_msgs::Geometry_msgs_Point>(idl_Visualization_msgs_Marker.points.begin(), idl_Visualization_msgs_Marker.points.end());
	}
	inline ROSCommon_msgs::Geometry_msgs_Point getPointsElemAtPos(const size_t &pos) const {
		return ROSCommon_msgs::Geometry_msgs_Point(idl_Visualization_msgs_Marker.points[pos]);
	}
	inline size_t getPointsSize() const { return idl_Visualization_msgs_Marker.points.size(); }
	inline bool isPointsEmpty() const { return idl_Visualization_msgs_Marker.points.empty(); }
	/**
	 * Setter methods for idl_Visualization_msgs_Marker.points of type vector<ROSCommon_msgs::Geometry_msgs_Point>
	 */
	inline Visualization_msgs_MarkerCore& setPoints(const std::vector<ROSCommon_msgs::Geometry_msgs_Point> &points) { 
		idl_Visualization_msgs_Marker.points.assign(points.begin(), points.end());
		return *this;
	}
	inline bool setPointsElemAtPos(const size_t &pos, const ROSCommon_msgs::Geometry_msgs_Point &elem) {
		if(pos < idl_Visualization_msgs_Marker.points.size()) {
			idl_Visualization_msgs_Marker.points[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertPointsVectorAtPos(const size_t &pos, const std::vector<ROSCommon_msgs::Geometry_msgs_Point> &data) {
		if(pos < idl_Visualization_msgs_Marker.points.size()) {
			idl_Visualization_msgs_Marker.points.insert(idl_Visualization_msgs_Marker.points.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizePoints(const size_t &size) { idl_Visualization_msgs_Marker.points.resize(size); }
	inline bool erasePointsElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Visualization_msgs_Marker.points.size() ) {
			idl_Visualization_msgs_Marker.points.erase(idl_Visualization_msgs_Marker.points.begin()+pos, idl_Visualization_msgs_Marker.points.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearPoints() { idl_Visualization_msgs_Marker.points.clear(); }
	
	// getter and setter for element Colors
	/**
	 * Getter methods for element idl_Visualization_msgs_Marker.colors of type vector<ROSRos_core::Std_msgs_ColorRGBA>
	 */
	inline std::vector<ROSRos_core::Std_msgs_ColorRGBA> getColorsCopy() const { 
		return std::vector<ROSRos_core::Std_msgs_ColorRGBA>(idl_Visualization_msgs_Marker.colors.begin(), idl_Visualization_msgs_Marker.colors.end());
	}
	inline ROSRos_core::Std_msgs_ColorRGBA getColorsElemAtPos(const size_t &pos) const {
		return ROSRos_core::Std_msgs_ColorRGBA(idl_Visualization_msgs_Marker.colors[pos]);
	}
	inline size_t getColorsSize() const { return idl_Visualization_msgs_Marker.colors.size(); }
	inline bool isColorsEmpty() const { return idl_Visualization_msgs_Marker.colors.empty(); }
	/**
	 * Setter methods for idl_Visualization_msgs_Marker.colors of type vector<ROSRos_core::Std_msgs_ColorRGBA>
	 */
	inline Visualization_msgs_MarkerCore& setColors(const std::vector<ROSRos_core::Std_msgs_ColorRGBA> &colors) { 
		idl_Visualization_msgs_Marker.colors.assign(colors.begin(), colors.end());
		return *this;
	}
	inline bool setColorsElemAtPos(const size_t &pos, const ROSRos_core::Std_msgs_ColorRGBA &elem) {
		if(pos < idl_Visualization_msgs_Marker.colors.size()) {
			idl_Visualization_msgs_Marker.colors[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertColorsVectorAtPos(const size_t &pos, const std::vector<ROSRos_core::Std_msgs_ColorRGBA> &data) {
		if(pos < idl_Visualization_msgs_Marker.colors.size()) {
			idl_Visualization_msgs_Marker.colors.insert(idl_Visualization_msgs_Marker.colors.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeColors(const size_t &size) { idl_Visualization_msgs_Marker.colors.resize(size); }
	inline bool eraseColorsElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Visualization_msgs_Marker.colors.size() ) {
			idl_Visualization_msgs_Marker.colors.erase(idl_Visualization_msgs_Marker.colors.begin()+pos, idl_Visualization_msgs_Marker.colors.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearColors() { idl_Visualization_msgs_Marker.colors.clear(); }
	
	// getter and setter for element Text
	inline std::string getText() const { return idl_Visualization_msgs_Marker.text; }
	inline Visualization_msgs_MarkerCore& setText(const std::string &text) { idl_Visualization_msgs_Marker.text = text; return *this; }
	
	// getter and setter for element Mesh_resource
	inline std::string getMesh_resource() const { return idl_Visualization_msgs_Marker.mesh_resource; }
	inline Visualization_msgs_MarkerCore& setMesh_resource(const std::string &mesh_resource) { idl_Visualization_msgs_Marker.mesh_resource = mesh_resource; return *this; }
	
	// getter and setter for element Mesh_use_embedded_materials
	inline bool getMesh_use_embedded_materials() const { return idl_Visualization_msgs_Marker.mesh_use_embedded_materials; }
	inline Visualization_msgs_MarkerCore& setMesh_use_embedded_materials(const bool &mesh_use_embedded_materials) { idl_Visualization_msgs_Marker.mesh_use_embedded_materials = mesh_use_embedded_materials; return *this; }
};

} /* namespace ROSCommon_msgs */
#endif /* ROSCOMMON_MSGS_VISUALIZATION_MSGS_MARKER_CORE_H_ */
